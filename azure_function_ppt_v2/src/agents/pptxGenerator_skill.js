const { BaseAgent } = require('./core/baseAgent');
const PptxGenJS = require('pptxgenjs');
const fs = require('fs');
const path = require('path');

/**
 * PptxGenerator Agent
 * Generates PowerPoint files using PptxGenJS based on structured content
 * NOTE: This is a placeholder - PptxGenJS integration to be completed in separate session
 */
class PptxGenerator extends BaseAgent {
    constructor() {
        super('PptxGenerator');
    }

    async process(input) {
        this.validateInput(input, ['structured_content', 'session_id']);

        const { structured_content, slide_estimate, session_id } = input;

        try {
            console.log('[PptxGenerator] Starting PowerPoint generation...');
            console.log(`[PptxGenerator] Processing ${structured_content.total_slides} slides`);

            // Use actual PptxGenJS implementation
            const result = await this.generateWithPptxGenJS(structured_content, session_id);

            console.log('[PptxGenerator] PowerPoint generation completed');
            return result;

        } catch (error) {
            console.error('[PptxGenerator] Generation failed:', error);
            throw new Error(`PowerPoint generation failed: ${error.message}`);
        }
    }

    /**
     * Placeholder method for PowerPoint generation
     * TODO: Replace with actual PptxGenJS implementation
     */
    async generatePowerPointPlaceholder(structuredContent, sessionId) {
        // Simulate processing time
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Generate filename
        const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        const filename = `presentation_${sessionId}_${timestamp}.pptx`;

        // Create placeholder base64 (empty presentation)
        // TODO: Replace with actual PptxGenJS generated content
        const placeholderBase64 = this.createPlaceholderPowerPoint();

        return {
            ppt_data: placeholderBase64,
            filename: filename,
            file_size_kb: Math.round(placeholderBase64.length / 1024),
            slide_count: structuredContent.total_slides,
            generation_method: 'placeholder',
            message: 'Placeholder PowerPoint generated - PptxGenJS integration pending'
        };
    }

    /**
     * Create a minimal placeholder PowerPoint in base64 format
     * TODO: Replace with actual PptxGenJS generation
     */
    createPlaceholderPowerPoint() {
        // This is a minimal base64 representation
        // In actual implementation, this will be generated by PptxGenJS
        return 'UEsDBBQAAAAIAA0AAABQAAAAAAAAAAEAAAABAAAAW0NvbnRlbnRfVHlwZXNdLnhtbA==';
    }

    /**
     * Generate PowerPoint using PptxGenJS with comprehensive layout support
     */
    async generateWithPptxGenJS(structuredContent, sessionId) {
        try {
            // Initialize PptxGenJS
            const pres = new PptxGenJS();
            
            // Configure 16:9 widescreen presentation
            pres.defineLayout({ 
                name: 'LAYOUT_16x9', 
                width: 10, 
                height: 5.625 
            });
            pres.layout = 'LAYOUT_16x9';

            // Set presentation properties
            pres.author = 'Document Generation System v2';
            pres.company = 'NCS';
            pres.subject = 'Generated Presentation';
            pres.title = structuredContent.presentation_title || 'Generated Presentation';


            console.log(`[PptxGenerator] Creating ${structuredContent.total_slides} slides`);

            // Generate all slides based on structured content
            for (let i = 0; i < structuredContent.slides.length; i++) {
                const slideData = structuredContent.slides[i];
                console.log(`[PptxGenerator] Creating slide ${i + 1}: ${slideData.layout}`);
                
                // Create slides with direct PptxGenJS implementation
                this.createSlideWithPptxGenJS(pres, slideData, i + 1);
            }

            // Generate filename
            const timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            const filename = `presentation_${sessionId}_${timestamp}.pptx`;

            // Generate base64 output
            console.log('[PptxGenerator] Generating PowerPoint file...');
            const base64Data = await pres.write('base64');

            // Save locally for testing (only in development)
            await this.saveLocalCopy(pres, filename);

            return {
                ppt_data: base64Data,
                filename: filename,
                file_size_kb: Math.round(base64Data.length / 1024),
                slide_count: structuredContent.total_slides,
                generation_method: 'pptxgenjs',
                message: 'PowerPoint presentation generated successfully with PptxGenJS'
            };

        } catch (error) {
            console.error('[PptxGenerator] PptxGenJS generation failed:', error);
            throw new Error(`PptxGenJS generation failed: ${error.message}`);
        }
    }


    /**
     * Create slides with PptxGenJS based on layout type and content
     */
    createSlideWithPptxGenJS(pres, slideData, slideNumber) {
        const slide = pres.addSlide();
        
        // Apply background image using correct PptxGenJS syntax
        const path = require('path');
        const fs = require('fs');
        
        // Use absolute path that we know works from testing
        const backgroundImagePath = path.join(__dirname, '../../template/background_image/ncs_bg_purple_blue.png');
        
        console.log(`[PptxGenerator] Slide ${slideNumber}: Checking background image at: ${backgroundImagePath}`);
        
        if (fs.existsSync(backgroundImagePath)) {
            console.log(`[PptxGenerator] Slide ${slideNumber}: ✓ Background image found, applying to slide`);
            // Set background image directly on slide object using proven syntax
            slide.background = { path: backgroundImagePath };
        } else {
            console.log(`[PptxGenerator] Slide ${slideNumber}: ❌ Background image not found, using white background`);
            slide.background = { color: 'FFFFFF' };
        }

        switch (slideData.layout) {
            case 'TITLE_SLIDE':
                this.createTitleSlide(slide, slideData);
                break;
                
            case 'AGENDA_SLIDE':
                this.createAgendaSlide(slide, slideData);
                break;
                
            case 'CONTENT_SLIDE':
            case 'OVERVIEW_SLIDE':
                this.createContentSlide(slide, slideData);
                break;
                
            case 'TABLE_SLIDE':
                this.createTableSlide(slide, slideData);
                break;
                
            case 'TWO_COLUMN_SLIDE':
                this.createTwoColumnSlide(slide, slideData);
                break;
                
            case 'TEXT_BOX_SLIDE':
                this.createTextBoxSlide(slide, slideData);
                break;
                
            case 'SUMMARY_SLIDE':
                this.createSummarySlide(slide, slideData);
                break;
                
            case 'THANK_YOU_SLIDE':
                this.createThankYouSlide(slide, slideData);
                break;
                
            default:
                // Default to content slide
                this.createContentSlide(slide, slideData);
        }
        
        // Add slide number
        if (slideNumber > 1) {
            slide.addText(`${slideNumber}`, {
                x: 9.2, y: 5.2, w: 0.5, h: 0.3,
                fontSize: 10,
                fontFace: 'Ubuntu',
                color: 'FFFFFF',
                align: 'right'
            });
        }
    }

    /**
     * Create title slide layout
     */
    createTitleSlide(slide, slideData) {
        // Main title
        slide.addText(slideData.title, {
            x: 1, y: 1.5, w: 8, h: 1.5,
            fontSize: 36,
            fontFace: 'Ubuntu',
            color: 'FFFFFF',
            bold: true,
            align: 'center'
        });

        // Subtitle if provided
        if (slideData.subtitle) {
            slide.addText(slideData.subtitle, {
                x: 1, y: 3, w: 8, h: 1,
                fontSize: 20,
                fontFace: 'Ubuntu',
                color: 'FFFFFF',
                align: 'center'
            });
        }

        // Date and author
        const currentDate = new Date().toLocaleDateString();
        slide.addText(`${currentDate}`, {
            x: 1, y: 4.5, w: 8, h: 0.5,
            fontSize: 14,
            fontFace: 'Ubuntu',
            color: 'FFFFFF',
            align: 'center'
        });

        // Add NCS logo to title slide
        const path = require('path');
        const ncsLogoPath = path.join(__dirname, '../../template/background_image/ncs_white.svg');
        
        // Method 1: Use your adjusted position (20.14cm from left)
        const logoX = 20.14 * 0.393701; // 7.93 inches (your corrected position)
        const logoY = 1.16 * 0.393701;  // 0.46 inches
        const logoW = 7.95 * 0.393701 * 0.54; // 1.69 inches (scaled 54%)
        const logoH = 2.91 * 0.393701 * 0.54; // 0.62 inches (scaled 54%)
        
        // Alternative Method 2: Simple top-right corner positioning
        // const slideWidth = 10; // 16:9 slide width in inches
        // const logoX = slideWidth - logoW - 0.2; // Right edge minus logo width minus small margin
        // const logoY = 0.2; // Small margin from top
        
        if (require('fs').existsSync(ncsLogoPath)) {
            slide.addImage({
                path: ncsLogoPath,
                x: logoX,
                y: logoY,
                w: logoW,
                h: logoH
            });
            console.log(`[PptxGenerator] NCS logo added to title slide at position (${logoX.toFixed(2)}, ${logoY.toFixed(2)})`);
        } else {
            console.log(`[PptxGenerator] NCS logo not found at: ${ncsLogoPath}`);
        }
    }

    /**
     * Create agenda slide layout
     */
    createAgendaSlide(slide, slideData) {
        // Title
        slide.addText(slideData.title, {
            x: 1, y: 0.5, w: 8, h: 0.8,
            fontSize: 28,
            fontFace: 'Ubuntu',
            color: 'FFFFFF',
            bold: true
        });

        // Agenda items as bullet points
        const bullets = this.extractBullets(slideData);
        if (bullets && bullets.length > 0) {
            const bulletTextArray = bullets.map(item => ({
                text: item,
                options: { bullet: true, fontSize: 18, fontFace: 'Ubuntu', color: 'FFFFFF' }
            }));
            
            slide.addText(bulletTextArray, {
                x: 1.5, y: 1.5, w: 7, h: 3.5,
                valign: 'top',
                lineSpacingMultiple: 1.3
            });
        }
    }

    /**
     * Create content slide with bullet points
     */
    createContentSlide(slide, slideData) {
        // Title
        slide.addText(slideData.title, {
            x: 1, y: 0.5, w: 8, h: 0.8,
            fontSize: 24,
            fontFace: 'Ubuntu',
            color: 'FFFFFF',
            bold: true
        });

        // Content as bullet points
        const bullets = this.extractBullets(slideData);
        if (bullets && bullets.length > 0) {
            const bulletTextArray = bullets.map(item => ({
                text: item,
                options: { bullet: true, fontSize: 16, fontFace: 'Ubuntu', color: 'FFFFFF' }
            }));
            
            slide.addText(bulletTextArray, {
                x: 1.5, y: 1.5, w: 7, h: 3.5,
                valign: 'top',
                lineSpacingMultiple: 1.4
            });
        }
    }

    /**
     * Create table slide layout
     */
    createTableSlide(slide, slideData) {
        // Title
        slide.addText(slideData.title, {
            x: 1, y: 0.5, w: 8, h: 0.8,
            fontSize: 24,
            fontFace: 'Ubuntu',
            color: 'FFFFFF',
            bold: true
        });

        // Table content
        const tableData = this.extractTableData(slideData);
        if (tableData && tableData.length > 0) {
            slide.addTable(tableData, {
                x: 1, y: 1.5, w: 8, h: 3,
                fontSize: 14,
                fontFace: 'Ubuntu',
                color: 'FFFFFF',
                border: { type: 'solid', color: 'FFFFFF', pt: 1 },
                fill: { color: '333333' },
                align: 'left',
                valign: 'middle'
            });
        }
    }

    /**
     * Create two-column slide layout
     */
    createTwoColumnSlide(slide, slideData) {
        // Title
        slide.addText(slideData.title, {
            x: 1, y: 0.5, w: 8, h: 0.8,
            fontSize: 24,
            fontFace: 'Ubuntu',
            color: 'FFFFFF',
            bold: true
        });

        // Extract column data
        const columnData = this.extractColumnData(slideData);
        
        // Left column
        if (columnData.left && columnData.left.length > 0) {
            const leftTextArray = columnData.left.map(item => ({
                text: item,
                options: { bullet: true, fontSize: 14, fontFace: 'Ubuntu', color: 'FFFFFF' }
            }));
            
            slide.addText(leftTextArray, {
                x: 1, y: 1.5, w: 3.8, h: 3.5,
                valign: 'top',
                lineSpacingMultiple: 1.3
            });
        }

        // Right column
        if (columnData.right && columnData.right.length > 0) {
            const rightTextArray = columnData.right.map(item => ({
                text: item,
                options: { bullet: true, fontSize: 14, fontFace: 'Ubuntu', color: 'FFFFFF' }
            }));
            
            slide.addText(rightTextArray, {
                x: 5.2, y: 1.5, w: 3.8, h: 3.5,
                valign: 'top',
                lineSpacingMultiple: 1.3
            });
        }
    }

    /**
     * Create text box slide layout for flexible positioning
     */
    createTextBoxSlide(slide, slideData) {
        // Title
        slide.addText(slideData.title, {
            x: 1, y: 0.5, w: 8, h: 0.8,
            fontSize: 24,
            fontFace: 'Ubuntu',
            color: 'FFFFFF',
            bold: true
        });

        // Text boxes with flexible positioning
        if (slideData.text_boxes && slideData.text_boxes.length > 0) {
            slideData.text_boxes.forEach((textBox, index) => {
                slide.addText(textBox.content, {
                    x: textBox.x || 1 + (index % 2) * 4,
                    y: textBox.y || 1.5 + Math.floor(index / 2) * 1.5,
                    w: textBox.w || 3.5,
                    h: textBox.h || 1,
                    fontSize: textBox.fontSize || 14,
                    fontFace: textBox.fontFace || 'Ubuntu',
                    color: textBox.color || 'FFFFFF',
                    align: textBox.align || 'left',
                    valign: textBox.valign || 'top'
                });
            });
        }
    }

    /**
     * Create summary slide layout
     */
    createSummarySlide(slide, slideData) {
        // Title
        slide.addText(slideData.title, {
            x: 1, y: 0.5, w: 8, h: 0.8,
            fontSize: 28,
            fontFace: 'Ubuntu',
            color: 'FFFFFF',
            bold: true
        });

        // Key takeaways
        const bullets = this.extractBullets(slideData);
        if (bullets && bullets.length > 0) {
            const takeawaysTextArray = bullets.map((item, index) => ({
                text: `${index + 1}. ${item}`,
                options: { fontSize: 16, fontFace: 'Ubuntu', color: 'FFFFFF' }
            }));
            
            slide.addText(takeawaysTextArray, {
                x: 1.5, y: 1.5, w: 7, h: 3.5,
                valign: 'top',
                lineSpacingMultiple: 1.4
            });
        }
    }

    /**
     * Create thank you slide layout
     */
    createThankYouSlide(slide, slideData) {
        // Thank you message
        slide.addText('Thank You', {
            x: 1, y: 2, w: 8, h: 1.5,
            fontSize: 48,
            fontFace: 'Ubuntu',
            color: 'FFFFFF',
            bold: true,
            align: 'center'
        });

        // Additional content from bullets
        const bullets = this.extractBullets(slideData);
        if (bullets && bullets.length > 0) {
            const bulletTextArray = bullets.map(item => ({
                text: item,
                options: { bullet: true, fontSize: 14, fontFace: 'Ubuntu', color: 'FFFFFF' }
            }));
            
            slide.addText(bulletTextArray, {
                x: 1.5, y: 3.5, w: 7, h: 1.5,
                valign: 'top',
                lineSpacingMultiple: 1.2
            });
        }
    }

    /**
     * Extract bullets from slide data based on content structure
     */
    extractBullets(slideData) {
        if (!slideData.content) return [];

        // Handle different content structures
        if (slideData.content.bullets && Array.isArray(slideData.content.bullets)) {
            return slideData.content.bullets;
        }
        
        // Fallback for direct content array
        if (Array.isArray(slideData.content)) {
            return slideData.content;
        }
        
        return [];
    }

    /**
     * Extract table data from slide data
     */
    extractTableData(slideData) {
        if (!slideData.content || !slideData.content.table) return [];

        const table = slideData.content.table;
        const tableRows = [];

        // Add headers if present
        if (table.headers && Array.isArray(table.headers)) {
            tableRows.push(table.headers);
        }

        // Add data rows
        if (table.rows && Array.isArray(table.rows)) {
            tableRows.push(...table.rows);
        }

        return tableRows;
    }

    /**
     * Extract column data for two-column slides
     */
    extractColumnData(slideData) {
        if (!slideData.content || !slideData.content.columns) {
            return { left: [], right: [] };
        }

        const columns = slideData.content.columns;
        return {
            left: Array.isArray(columns.left) ? columns.left : [],
            right: Array.isArray(columns.right) ? columns.right : []
        };
    }

    /**
     * Save a local copy of the PowerPoint file for testing
     */
    async saveLocalCopy(pres, filename) {
        try {
            // Only save locally in development mode
            if (process.env.NODE_ENV === 'production' || process.env.WEBSITE_SITE_NAME) {
                return; // Skip in Azure production
            }

            // Create local_output directory if it doesn't exist
            const outputDir = path.join(__dirname, '../../local_output');
            if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
                console.log('[PptxGenerator] Created local_output directory');
            }

            // Save the PowerPoint file locally
            const localPath = path.join(outputDir, filename);
            await pres.writeFile({ fileName: localPath });
            
            console.log(`[PptxGenerator] PowerPoint saved locally: ${localPath}`);

        } catch (error) {
            console.warn('[PptxGenerator] Failed to save local copy:', error.message);
            // Don't throw error - local save is optional
        }
    }
}

module.exports = { PptxGenerator };